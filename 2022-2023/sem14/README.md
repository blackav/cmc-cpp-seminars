# Семинар 13

## Темы, рассмотренные на семинаре

Каждый класс в иерархии наследования определяет свое пространство имен,
поэтому пространство имен производного класса является вложенным
в пространство имен базового класса. При подборе кандидатов на перегрузку
в производном классе по умолчанию не учитываются функции, объявленные
в базовых классах, так как это уже другие пространства имен.
Добавить функции базового класса в пространство имен производного
класса можно с помощью `using`.

См. [пример 1](1.cpp).

Параметры по умолчанию полностью обрабатываются компилятором
во время компиляции. Для определения значения параметра по умолчанию
компилятор использует статический тип (то есть тип, приписанный
объекту при компиляции программы), а не динамический тип.

См. [пример 2](2.cpp).

Права доступа (`private`, `public`) никак не взаимодействуют с
перегрузкой функций. Множество кандидатов на перегрузку строится
без учета прав доступа, но если в итоге оказывается, что
наилучшим кандидатом является недоступная функция, возникает
ошибка компиляции.

См. [пример 3](3.cpp).

При множественном наследовании пространство имен производного класса
является вложенным по отношению к пространствам имен базовых классов.
Для устранения неоднозначности потребуется явное указание пространства имен.

См. [пример 4](4.cpp).

При множественном наследовании операция `static_cast` может менять
битовое значение указателя: прибавлять при преобразовании от производного
к базовому и вычитать при преобразовании от базового к производному.
Реализация наследования и виртуальных вызовов требует генерации
специальных промежуточных функций-трамплинов, которые модифицируют
правильным образом значение `this`. Преобразование указателя на класс
в `void *` приводит к UB.

См. [пример 5](5.cpp).

Ромбовидное наследование приводит к тому, что в объекте производного
класса оказываются агрегированы несколько разных объектов общего
базового класса.

См. [пример 6](6.cpp).

При виртуальном наследовании объект производного класса содержит единственный
объект общего базового класса. При виртуальном наследовании объект
производного класса не агрегирует объект базового класса, а хранит
указатель на него.

См. [пример 7](7.cpp).
