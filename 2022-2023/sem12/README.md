# Семинар 12

## Темы, рассмотренные на семинаре

Шаблонный класс `std::iterator_traits` для унифицированного
получения свойств итераторов и указателей.

См. [пример 1](1.cpp).

Специализация шаблонных классов. Статические поля класса для типов
(например `value_type` или `type`) и для констант (`value`).

См. [пример 2](2.cpp).

Частичная специализация шаблонных классов.
(внимание! шаблонные функции нельзя частично специализировать)

См. [пример 3](3.cpp).

Шаблонные функции с переменным числом шаблонных параметров.
Универсальные ссылки в шаблонных функциях. Контексты, в которых
можно раскрыть variable arguments pack. Универсальная
forwarding шаблонная функция.

Шаблонные классы с переменным числом шаблонных параметров.
Сопоставление с параметрами шаблона для "откусывания" по
одному параметру из пакета переменных параметров.

"Рекурсивное" раскрытие шаблона в случае параметра шаблона целого типа.

Идиома SFINAE. Использование `std::enable_if` для выбора
варианта шаблонной функции при выполнении условий.

См. [пример 5](5.cpp).

Использование `std::enable_if` и `<type_traits>` для выбора
варианта шаблонной функции в зависимости от свойств типа.

См. [пример 6](6.cpp).
